{
    "id": "041",
    "desc": "\n105-08.\n\nDepth-first search for Binary Tree\n\ntypedef struct node_s {\nchar data;\nstruct node_s * left;\nstruct node_s * mid;\nstruct node_s * right;\n} node_t;\n\ntypedef struct node_s {\nnode_t * root;\n}\n\ntypedef node_t * nodep_t;\n\n//s為樹的敘述，第一個字元為Root\n//(1)例如ACBE，則Root為A，left為C，mid為B，right為E\n//(2.1)若先輸入DE，則Root為D，left為E\n//(2.2)再輸入DF，則此時Root為D，left為E，mid為F\n(1)void BuildTree(nodep_t *node, char* s);\n//利用Depth-first search，尋訪規則為Root先拜訪，再由children中字元最小的開始尋訪\n(2)void DFS(nodep_t *node);\n\n---------------------\n輸入說明：\n\ni, 樹的敘述: function(1)\np: function(2)\ne: 程式結束\n\n輸出說明：\n\np (印出):\n(1)沒有tree 印出 null\n(2)每個data中間沒空白\n\n",
    "tests": [
        {
            "input": "p\ni\nACBE\ni\nCD\ni\nDH\ni\nEF\np\ni\nHJ\ni\nHG\ni\nGI\np\ne\n",
            "output": "null\nABCDHEF\nABCDHGIJEF\n"
        }
    ]
}